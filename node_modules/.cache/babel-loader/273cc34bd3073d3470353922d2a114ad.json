{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/utils/insertcontent\n */\nimport Position from '../position';\nimport LivePosition from '../liveposition';\nimport Element from '../element';\nimport Range from '../range';\nimport DocumentSelection from '../documentselection';\nimport Selection from '../selection';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * Inserts content into the editor (specified selection) as one would expect the paste functionality to work.\n *\n * It takes care of removing the selected content, splitting elements (if needed), inserting elements and merging elements appropriately.\n *\n * Some examples:\n *\n * \t\t<p>x^</p> + <p>y</p> => <p>x</p><p>y</p> => <p>xy[]</p>\n * \t\t<p>x^y</p> + <p>z</p> => <p>x</p>^<p>y</p> + <p>z</p> => <p>x</p><p>z</p><p>y</p> => <p>xz[]y</p>\n * \t\t<p>x^y</p> + <img /> => <p>x</p>^<p>y</p> + <img /> => <p>x</p><img /><p>y</p>\n * \t\t<p>x</p><p>^</p><p>z</p> + <p>y</p> => <p>x</p><p>y[]</p><p>z</p> (no merging)\n * \t\t<p>x</p>[<img />]<p>z</p> + <p>y</p> => <p>x</p>^<p>z</p> + <p>y</p> => <p>x</p><p>y[]</p><p>z</p>\n *\n * If an instance of {@link module:engine/model/selection~Selection} is passed as `selectable` it will be modified\n * to the insertion selection (equal to a range to be selected after insertion).\n *\n * If `selectable` is not passed, the content will be inserted using the current selection of the model document.\n *\n * **Note:** Use {@link module:engine/model/model~Model#insertContent} instead of this function.\n * This function is only exposed to be reusable in algorithms which change the {@link module:engine/model/model~Model#insertContent}\n * method's behavior.\n *\n * @param {module:engine/model/model~Model} model The model in context of which the insertion\n * should be performed.\n * @param {module:engine/model/documentfragment~DocumentFragment|module:engine/model/item~Item} content The content to insert.\n * @param {module:engine/model/selection~Selectable} [selectable=model.document.selection]\n * Selection into which the content should be inserted.\n * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n * @returns {module:engine/model/range~Range} Range which contains all the performed changes. This is a range that, if removed,\n * would return the model to the state before the insertion. If no changes were preformed by `insertContent`, returns a range collapsed\n * at the insertion position.\n */\n\nexport default function insertContent(model, content, selectable, placeOrOffset) {\n  return model.change(writer => {\n    let selection;\n\n    if (!selectable) {\n      selection = model.document.selection;\n    } else if (selectable instanceof Selection || selectable instanceof DocumentSelection) {\n      selection = selectable;\n    } else {\n      selection = writer.createSelection(selectable, placeOrOffset);\n    }\n\n    if (!selection.isCollapsed) {\n      model.deleteContent(selection, {\n        doNotAutoparagraph: true\n      });\n    }\n\n    const insertion = new Insertion(model, writer, selection.anchor);\n    let nodesToInsert;\n\n    if (content.is('documentFragment')) {\n      nodesToInsert = content.getChildren();\n    } else {\n      nodesToInsert = [content];\n    }\n\n    insertion.handleNodes(nodesToInsert);\n    const newRange = insertion.getSelectionRange();\n    /* istanbul ignore else */\n\n    if (newRange) {\n      if (selection instanceof DocumentSelection) {\n        writer.setSelection(newRange);\n      } else {\n        selection.setTo(newRange);\n      }\n    } else {// We are not testing else because it's a safe check for unpredictable edge cases:\n      // an insertion without proper range to select.\n      //\n      // @if CK_DEBUG // console.warn( 'Cannot determine a proper selection range after insertion.' );\n    }\n\n    const affectedRange = insertion.getAffectedRange() || model.createRange(selection.anchor);\n    insertion.destroy();\n    return affectedRange;\n  });\n}\n/**\n * Utility class for performing content insertion.\n *\n * @private\n */\n\nclass Insertion {\n  constructor(model, writer, position) {\n    /**\n     * The model in context of which the insertion should be performed.\n     *\n     * @member {module:engine/model~Model} #model\n     */\n    this.model = model;\n    /**\n     * Batch to which operations will be added.\n     *\n     * @member {module:engine/controller/writer~Batch} #writer\n     */\n\n    this.writer = writer;\n    /**\n     * The position at which (or near which) the next node will be inserted.\n     *\n     * @member {module:engine/model/position~Position} #position\n     */\n\n    this.position = position;\n    /**\n     * Elements with which the inserted elements can be merged.\n     *\n     *\t\t<p>x^</p><p>y</p> + <p>z</p> (can merge to <p>x</p>)\n     *\t\t<p>x</p><p>^y</p> + <p>z</p> (can merge to <p>y</p>)\n     *\t\t<p>x^y</p> + <p>z</p> (can merge to <p>xy</p> which will be split during the action,\n     *\t\t\t\t\t\t\t\tso both its pieces will be added to this set)\n     *\n     *\n     * @member {Set} #canMergeWith\n     */\n\n    this.canMergeWith = new Set([this.position.parent]);\n    /**\n     * Schema of the model.\n     *\n     * @member {module:engine/model/schema~Schema} #schema\n     */\n\n    this.schema = model.schema;\n    /**\n     * The temporary DocumentFragment used for grouping multiple nodes for single insert operation.\n     *\n     * @private\n     * @type {module:engine/model/documentfragment~DocumentFragment}\n     */\n\n    this._documentFragment = writer.createDocumentFragment();\n    /**\n     * The current position in the temporary DocumentFragment.\n     *\n     * @private\n     * @type {module:engine/model/position~Position}\n     */\n\n    this._documentFragmentPosition = writer.createPositionAt(this._documentFragment, 0);\n    /**\n     * The reference to the first inserted node.\n     *\n     * @private\n     * @type {module:engine/model/node~Node}\n     */\n\n    this._firstNode = null;\n    /**\n     * The reference to the last inserted node.\n     *\n     * @private\n     * @type {module:engine/model/node~Node}\n     */\n\n    this._lastNode = null;\n    /**\n     * The array of nodes that should be cleaned of not allowed attributes.\n     *\n     * @private\n     * @type {Array.<module:engine/model/node~Node>}\n     */\n\n    this._filterAttributesOf = [];\n    /**\n     * Beginning of the affected range. See {@link module:engine/model/utils/insertcontent~Insertion#getAffectedRange}.\n     *\n     * @private\n     * @member {module:engine/model/liveposition~LivePosition|null} #_affectedStart\n     */\n\n    this._affectedStart = null;\n    /**\n     * End of the affected range. See {@link module:engine/model/utils/insertcontent~Insertion#getAffectedRange}.\n     *\n     * @private\n     * @member {module:engine/model/liveposition~LivePosition|null} #_affectedEnd\n     */\n\n    this._affectedEnd = null;\n  }\n  /**\n   * Handles insertion of a set of nodes.\n   *\n   * @param {Iterable.<module:engine/model/node~Node>} nodes Nodes to insert.\n   */\n\n\n  handleNodes(nodes) {\n    for (const node of Array.from(nodes)) {\n      this._handleNode(node);\n    } // Insert nodes collected in temporary DocumentFragment.\n\n\n    this._insertPartialFragment(); // After the content was inserted we may try to merge it with its next sibling if the selection was in it initially.\n    // Merging with the previous sibling was performed just after inserting the first node to the document.\n\n\n    this._mergeOnRight(); // TMP this will become a post-fixer.\n\n\n    this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer);\n    this._filterAttributesOf = [];\n  }\n  /**\n   * Returns range to be selected after insertion.\n   * Returns `null` if there is no valid range to select after insertion.\n   *\n   * @returns {module:engine/model/range~Range|null}\n   */\n\n\n  getSelectionRange() {\n    if (this.nodeToSelect) {\n      return Range._createOn(this.nodeToSelect);\n    }\n\n    return this.model.schema.getNearestSelectionRange(this.position);\n  }\n  /**\n   * Returns a range which contains all the performed changes. This is a range that, if removed, would return the model to the state\n   * before the insertion. Returns `null` if no changes were done.\n   *\n   * @returns {module:engine/model/range~Range|null}\n   */\n\n\n  getAffectedRange() {\n    if (!this._affectedStart) {\n      return null;\n    }\n\n    return new Range(this._affectedStart, this._affectedEnd);\n  }\n  /**\n   * Destroys `Insertion` instance.\n   */\n\n\n  destroy() {\n    if (this._affectedStart) {\n      this._affectedStart.detach();\n    }\n\n    if (this._affectedEnd) {\n      this._affectedEnd.detach();\n    }\n  }\n  /**\n   * Handles insertion of a single node.\n   *\n   * @private\n   * @param {module:engine/model/node~Node} node\n   */\n\n\n  _handleNode(node) {\n    // Let's handle object in a special way.\n    // * They should never be merged with other elements.\n    // * If they are not allowed in any of the selection ancestors, they could be either autoparagraphed or totally removed.\n    if (this.schema.isObject(node)) {\n      this._handleObject(node);\n\n      return;\n    } // Try to find a place for the given node.\n    // Split the position.parent's branch up to a point where the node can be inserted.\n    // If it isn't allowed in the whole branch, then of course don't split anything.\n\n\n    const isAllowed = this._checkAndSplitToAllowedPosition(node);\n\n    if (!isAllowed) {\n      this._handleDisallowedNode(node);\n\n      return;\n    } // Add node to the current temporary DocumentFragment.\n\n\n    this._appendToFragment(node); // Store the first and last nodes for easy access for merging with sibling nodes.\n\n\n    if (!this._firstNode) {\n      this._firstNode = node;\n    }\n\n    this._lastNode = node;\n  }\n  /**\n   * Inserts the temporary DocumentFragment into the model.\n   *\n   * @private\n   */\n\n\n  _insertPartialFragment() {\n    if (this._documentFragment.isEmpty) {\n      return;\n    }\n\n    const livePosition = LivePosition.fromPosition(this.position, 'toNext');\n\n    this._setAffectedBoundaries(this.position); // If the very first node of the whole insertion process is inserted, insert it separately for OT reasons (undo).\n    // Note: there can be multiple calls to `_insertPartialFragment()` during one insertion process.\n    // Note: only the very first node can be merged so we have to do separate operation only for it.\n\n\n    if (this._documentFragment.getChild(0) == this._firstNode) {\n      this.writer.insert(this._firstNode, this.position); // We must merge the first node just after inserting it to avoid problems with OT.\n      // (See: https://github.com/ckeditor/ckeditor5/pull/8773#issuecomment-760945652).\n\n      this._mergeOnLeft();\n\n      this.position = livePosition.toPosition();\n    } // Insert the remaining nodes from document fragment.\n\n\n    if (!this._documentFragment.isEmpty) {\n      this.writer.insert(this._documentFragment, this.position);\n    }\n\n    this._documentFragmentPosition = this.writer.createPositionAt(this._documentFragment, 0);\n    this.position = livePosition.toPosition();\n    livePosition.detach();\n  }\n  /**\n   * @private\n   * @param {module:engine/model/element~Element} node The object element.\n   */\n\n\n  _handleObject(node) {\n    // Try finding it a place in the tree.\n    if (this._checkAndSplitToAllowedPosition(node)) {\n      this._appendToFragment(node);\n    } // Try autoparagraphing.\n    else {\n        this._tryAutoparagraphing(node);\n      }\n  }\n  /**\n   * @private\n   * @param {module:engine/model/node~Node} node The disallowed node which needs to be handled.\n   */\n\n\n  _handleDisallowedNode(node) {\n    // If the node is an element, try inserting its children (strip the parent).\n    if (node.is('element')) {\n      this.handleNodes(node.getChildren());\n    } // If text is not allowed, try autoparagraphing it.\n    else {\n        this._tryAutoparagraphing(node);\n      }\n  }\n  /**\n   * Append a node to the temporary DocumentFragment.\n   *\n   * @private\n   * @param {module:engine/model/node~Node} node The node to insert.\n   */\n\n\n  _appendToFragment(node) {\n    /* istanbul ignore if */\n    if (!this.schema.checkChild(this.position, node)) {\n      // Algorithm's correctness check. We should never end up here but it's good to know that we did.\n      // Note that it would often be a silent issue if we insert node in a place where it's not allowed.\n\n      /**\n       * Given node cannot be inserted on the given position.\n       *\n       * @error insertcontent-wrong-position\n       * @param {module:engine/model/node~Node} node Node to insert.\n       * @param {module:engine/model/position~Position} position Position to insert the node at.\n       */\n      throw new CKEditorError('insertcontent-wrong-position', this, {\n        node,\n        position: this.position\n      });\n    }\n\n    this.writer.insert(node, this._documentFragmentPosition);\n    this._documentFragmentPosition = this._documentFragmentPosition.getShiftedBy(node.offsetSize); // The last inserted object should be selected because we can't put a collapsed selection after it.\n\n    if (this.schema.isObject(node) && !this.schema.checkChild(this.position, '$text')) {\n      this.nodeToSelect = node;\n    } else {\n      this.nodeToSelect = null;\n    }\n\n    this._filterAttributesOf.push(node);\n  }\n  /**\n   * Sets `_affectedStart` and `_affectedEnd` to the given `position`. Should be used before a change is done during insertion process to\n   * mark the affected range.\n   *\n   * This method is used before inserting a node or splitting a parent node. `_affectedStart` and `_affectedEnd` are also changed\n   * during merging, but the logic there is more complicated so it is left out of this function.\n   *\n   * @private\n   * @param {module:engine/model/position~Position} position\n   */\n\n\n  _setAffectedBoundaries(position) {\n    // Set affected boundaries stickiness so that those position will \"expand\" when something is inserted in between them:\n    // <paragraph>Foo][bar</paragraph> -> <paragraph>Foo]xx[bar</paragraph>\n    // This is why it cannot be a range but two separate positions.\n    if (!this._affectedStart) {\n      this._affectedStart = LivePosition.fromPosition(position, 'toPrevious');\n    } // If `_affectedEnd` is before the new boundary position, expand `_affectedEnd`. This can happen if first inserted node was\n    // inserted into the parent but the next node is moved-out of that parent:\n    // (1) <paragraph>Foo][</paragraph> -> <paragraph>Foo]xx[</paragraph>\n    // (2) <paragraph>Foo]xx[</paragraph> -> <paragraph>Foo]xx</paragraph><widget></widget>[\n\n\n    if (!this._affectedEnd || this._affectedEnd.isBefore(position)) {\n      if (this._affectedEnd) {\n        this._affectedEnd.detach();\n      }\n\n      this._affectedEnd = LivePosition.fromPosition(position, 'toNext');\n    }\n  }\n  /**\n   * Merges the previous sibling of the first node if it should be merged.\n   *\n   * After the content was inserted we may try to merge it with its siblings.\n   * This should happen only if the selection was in those elements initially.\n   *\n   * @private\n   */\n\n\n  _mergeOnLeft() {\n    const node = this._firstNode;\n\n    if (!(node instanceof Element)) {\n      return;\n    }\n\n    if (!this._canMergeLeft(node)) {\n      return;\n    }\n\n    const mergePosLeft = LivePosition._createBefore(node);\n\n    mergePosLeft.stickiness = 'toNext';\n    const livePosition = LivePosition.fromPosition(this.position, 'toNext'); // If `_affectedStart` is sames as merge position, it means that the element \"marked\" by `_affectedStart` is going to be\n    // removed and its contents will be moved. This won't transform `LivePosition` so `_affectedStart` needs to be moved\n    // by hand to properly reflect affected range. (Due to `_affectedStart` and `_affectedEnd` stickiness, the \"range\" is\n    // shown as `][`).\n    //\n    // Example - insert `<paragraph>Abc</paragraph><paragraph>Xyz</paragraph>` at the end of `<paragraph>Foo^</paragraph>`:\n    //\n    // <paragraph>Foo</paragraph><paragraph>Bar</paragraph>   -->\n    // <paragraph>Foo</paragraph>]<paragraph>Abc</paragraph><paragraph>Xyz</paragraph>[<paragraph>Bar</paragraph>   -->\n    // <paragraph>Foo]Abc</paragraph><paragraph>Xyz</paragraph>[<paragraph>Bar</paragraph>\n    //\n    // Note, that if we are here then something must have been inserted, so `_affectedStart` and `_affectedEnd` have to be set.\n\n    if (this._affectedStart.isEqual(mergePosLeft)) {\n      this._affectedStart.detach();\n\n      this._affectedStart = LivePosition._createAt(mergePosLeft.nodeBefore, 'end', 'toPrevious');\n    } // We need to update the references to the first and last nodes if they will be merged into the previous sibling node\n    // because the reference would point to the removed node.\n    //\n    // <p>A^A</p> + <p>X</p>\n    //\n    // <p>A</p>^<p>A</p>\n    // <p>A</p><p>X</p><p>A</p>\n    // <p>AX</p><p>A</p>\n    // <p>AXA</p>\n\n\n    if (this._firstNode === this._lastNode) {\n      this._firstNode = mergePosLeft.nodeBefore;\n      this._lastNode = mergePosLeft.nodeBefore;\n    }\n\n    this.writer.merge(mergePosLeft); // If only one element (the merged one) is in the \"affected range\", also move the affected range end appropriately.\n    //\n    // Example - insert `<paragraph>Abc</paragraph>` at the of `<paragraph>Foo^</paragraph>`:\n    //\n    // <paragraph>Foo</paragraph><paragraph>Bar</paragraph>   -->\n    // <paragraph>Foo</paragraph>]<paragraph>Abc</paragraph>[<paragraph>Bar</paragraph>   -->\n    // <paragraph>Foo]Abc</paragraph>[<paragraph>Bar</paragraph>   -->\n    // <paragraph>Foo]Abc[</paragraph><paragraph>Bar</paragraph>\n\n    if (mergePosLeft.isEqual(this._affectedEnd) && this._firstNode === this._lastNode) {\n      this._affectedEnd.detach();\n\n      this._affectedEnd = LivePosition._createAt(mergePosLeft.nodeBefore, 'end', 'toNext');\n    }\n\n    this.position = livePosition.toPosition();\n    livePosition.detach(); // After merge elements that were marked by _insert() to be filtered might be gone so\n    // we need to mark the new container.\n\n    this._filterAttributesOf.push(this.position.parent);\n\n    mergePosLeft.detach();\n  }\n  /**\n   * Merges the next sibling of the last node if it should be merged.\n   *\n   * After the content was inserted we may try to merge it with its siblings.\n   * This should happen only if the selection was in those elements initially.\n   *\n   * @private\n   */\n\n\n  _mergeOnRight() {\n    const node = this._lastNode;\n\n    if (!(node instanceof Element)) {\n      return;\n    }\n\n    if (!this._canMergeRight(node)) {\n      return;\n    }\n\n    const mergePosRight = LivePosition._createAfter(node);\n\n    mergePosRight.stickiness = 'toNext';\n    /* istanbul ignore if */\n\n    if (!this.position.isEqual(mergePosRight)) {\n      // Algorithm's correctness check. We should never end up here but it's good to know that we did.\n      // At this point the insertion position should be after the node we'll merge. If it isn't,\n      // it should need to be secured as in the left merge case.\n\n      /**\n       * An internal error occurred when merging inserted content with its siblings.\n       * The insertion position should equal the merge position.\n       *\n       * If you encountered this error, report it back to the CKEditor 5 team\n       * with as many details as possible regarding the content being inserted and the insertion position.\n       *\n       * @error insertcontent-invalid-insertion-position\n       */\n      throw new CKEditorError('insertcontent-invalid-insertion-position', this);\n    } // Move the position to the previous node, so it isn't moved to the graveyard on merge.\n    // <p>x</p>[]<p>y</p> => <p>x[]</p><p>y</p>\n\n\n    this.position = Position._createAt(mergePosRight.nodeBefore, 'end'); // Explanation of setting position stickiness to `'toPrevious'`:\n    // OK:  <p>xx[]</p> + <p>yy</p> => <p>xx[]yy</p> (when sticks to previous)\n    // NOK: <p>xx[]</p> + <p>yy</p> => <p>xxyy[]</p> (when sticks to next)\n\n    const livePosition = LivePosition.fromPosition(this.position, 'toPrevious'); // See comment in `_mergeOnLeft()` on moving `_affectedStart`.\n\n    if (this._affectedEnd.isEqual(mergePosRight)) {\n      this._affectedEnd.detach();\n\n      this._affectedEnd = LivePosition._createAt(mergePosRight.nodeBefore, 'end', 'toNext');\n    } // We need to update the references to the first and last nodes if they will be merged into the previous sibling node\n    // because the reference would point to the removed node.\n    //\n    // <p>A^A</p> + <p>X</p>\n    //\n    // <p>A</p>^<p>A</p>\n    // <p>A</p><p>X</p><p>A</p>\n    // <p>AX</p><p>A</p>\n    // <p>AXA</p>\n\n\n    if (this._firstNode === this._lastNode) {\n      this._firstNode = mergePosRight.nodeBefore;\n      this._lastNode = mergePosRight.nodeBefore;\n    }\n\n    this.writer.merge(mergePosRight); // See comment in `_mergeOnLeft()` on moving `_affectedStart`.\n\n    if (mergePosRight.getShiftedBy(-1).isEqual(this._affectedStart) && this._firstNode === this._lastNode) {\n      this._affectedStart.detach();\n\n      this._affectedStart = LivePosition._createAt(mergePosRight.nodeBefore, 0, 'toPrevious');\n    }\n\n    this.position = livePosition.toPosition();\n    livePosition.detach(); // After merge elements that were marked by _insert() to be filtered might be gone so\n    // we need to mark the new container.\n\n    this._filterAttributesOf.push(this.position.parent);\n\n    mergePosRight.detach();\n  }\n  /**\n   * Checks whether specified node can be merged with previous sibling element.\n   *\n   * @private\n   * @param {module:engine/model/node~Node} node The node which could potentially be merged.\n   * @returns {Boolean}\n   */\n\n\n  _canMergeLeft(node) {\n    const previousSibling = node.previousSibling;\n    return previousSibling instanceof Element && this.canMergeWith.has(previousSibling) && this.model.schema.checkMerge(previousSibling, node);\n  }\n  /**\n   * Checks whether specified node can be merged with next sibling element.\n   *\n   * @private\n   * @param {module:engine/model/node~Node} node The node which could potentially be merged.\n   * @returns {Boolean}\n   */\n\n\n  _canMergeRight(node) {\n    const nextSibling = node.nextSibling;\n    return nextSibling instanceof Element && this.canMergeWith.has(nextSibling) && this.model.schema.checkMerge(node, nextSibling);\n  }\n  /**\n   * Tries wrapping the node in a new paragraph and inserting it this way.\n   *\n   * @private\n   * @param {module:engine/model/node~Node} node The node which needs to be autoparagraphed.\n   */\n\n\n  _tryAutoparagraphing(node) {\n    const paragraph = this.writer.createElement('paragraph'); // Do not autoparagraph if the paragraph won't be allowed there,\n    // cause that would lead to an infinite loop. The paragraph would be rejected in\n    // the next _handleNode() call and we'd be here again.\n\n    if (this._getAllowedIn(paragraph, this.position.parent) && this.schema.checkChild(paragraph, node)) {\n      paragraph._appendChild(node);\n\n      this._handleNode(paragraph);\n    }\n  }\n  /**\n   * @private\n   * @param {module:engine/model/node~Node} node\n   * @returns {Boolean} Whether an allowed position was found.\n   * `false` is returned if the node isn't allowed at any position up in the tree, `true` if was.\n   */\n\n\n  _checkAndSplitToAllowedPosition(node) {\n    const allowedIn = this._getAllowedIn(node, this.position.parent);\n\n    if (!allowedIn) {\n      return false;\n    } // Insert nodes collected in temporary DocumentFragment if the position parent needs change to process further nodes.\n\n\n    if (allowedIn != this.position.parent) {\n      this._insertPartialFragment();\n    }\n\n    while (allowedIn != this.position.parent) {\n      // If a parent which we'd need to leave is a limit element, break.\n      if (this.schema.isLimit(this.position.parent)) {\n        return false;\n      }\n\n      if (this.position.isAtStart) {\n        // If insertion position is at the beginning of the parent, move it out instead of splitting.\n        // <p>^Foo</p> -> ^<p>Foo</p>\n        const parent = this.position.parent;\n        this.position = this.writer.createPositionBefore(parent); // Special case – parent is empty (<p>^</p>).\n        //\n        // 1. parent.isEmpty\n        // We can remove the element after moving insertion position out of it.\n        //\n        // 2. parent.parent === allowedIn\n        // However parent should remain in place when allowed element is above limit element in document tree.\n        // For example there shouldn't be allowed to remove empty paragraph from tableCell, when is pasted\n        // content allowed in $root.\n\n        if (parent.isEmpty && parent.parent === allowedIn) {\n          this.writer.remove(parent);\n        }\n      } else if (this.position.isAtEnd) {\n        // If insertion position is at the end of the parent, move it out instead of splitting.\n        // <p>Foo^</p> -> <p>Foo</p>^\n        this.position = this.writer.createPositionAfter(this.position.parent);\n      } else {\n        const tempPos = this.writer.createPositionAfter(this.position.parent);\n\n        this._setAffectedBoundaries(this.position);\n\n        this.writer.split(this.position);\n        this.position = tempPos;\n        this.canMergeWith.add(this.position.nodeAfter);\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Gets the element in which the given node is allowed. It checks the passed element and all its ancestors.\n   *\n   * @private\n   * @param {module:engine/model/node~Node} node The node to check.\n   * @param {module:engine/model/element~Element} element The element in which the node's correctness should be checked.\n   * @returns {module:engine/model/element~Element|null}\n   */\n\n\n  _getAllowedIn(node, element) {\n    if (this.schema.checkChild(element, node)) {\n      return element;\n    }\n\n    if (element.parent) {\n      return this._getAllowedIn(node, element.parent);\n    }\n\n    return null;\n  }\n\n}","map":{"version":3,"sources":["/home/radhetians/Desktop/frontend/node_modules/@ckeditor/ckeditor5-engine/src/model/utils/insertcontent.js"],"names":["Position","LivePosition","Element","Range","DocumentSelection","Selection","CKEditorError","insertContent","model","content","selectable","placeOrOffset","change","writer","selection","document","createSelection","isCollapsed","deleteContent","doNotAutoparagraph","insertion","Insertion","anchor","nodesToInsert","is","getChildren","handleNodes","newRange","getSelectionRange","setSelection","setTo","affectedRange","getAffectedRange","createRange","destroy","constructor","position","canMergeWith","Set","parent","schema","_documentFragment","createDocumentFragment","_documentFragmentPosition","createPositionAt","_firstNode","_lastNode","_filterAttributesOf","_affectedStart","_affectedEnd","nodes","node","Array","from","_handleNode","_insertPartialFragment","_mergeOnRight","removeDisallowedAttributes","nodeToSelect","_createOn","getNearestSelectionRange","detach","isObject","_handleObject","isAllowed","_checkAndSplitToAllowedPosition","_handleDisallowedNode","_appendToFragment","isEmpty","livePosition","fromPosition","_setAffectedBoundaries","getChild","insert","_mergeOnLeft","toPosition","_tryAutoparagraphing","checkChild","getShiftedBy","offsetSize","push","isBefore","_canMergeLeft","mergePosLeft","_createBefore","stickiness","isEqual","_createAt","nodeBefore","merge","_canMergeRight","mergePosRight","_createAfter","previousSibling","has","checkMerge","nextSibling","paragraph","createElement","_getAllowedIn","_appendChild","allowedIn","isLimit","isAtStart","createPositionBefore","remove","isAtEnd","createPositionAfter","tempPos","split","add","nodeAfter","element"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/utils/insertcontent\n */\n\nimport Position from '../position';\nimport LivePosition from '../liveposition';\nimport Element from '../element';\nimport Range from '../range';\nimport DocumentSelection from '../documentselection';\nimport Selection from '../selection';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * Inserts content into the editor (specified selection) as one would expect the paste functionality to work.\n *\n * It takes care of removing the selected content, splitting elements (if needed), inserting elements and merging elements appropriately.\n *\n * Some examples:\n *\n * \t\t<p>x^</p> + <p>y</p> => <p>x</p><p>y</p> => <p>xy[]</p>\n * \t\t<p>x^y</p> + <p>z</p> => <p>x</p>^<p>y</p> + <p>z</p> => <p>x</p><p>z</p><p>y</p> => <p>xz[]y</p>\n * \t\t<p>x^y</p> + <img /> => <p>x</p>^<p>y</p> + <img /> => <p>x</p><img /><p>y</p>\n * \t\t<p>x</p><p>^</p><p>z</p> + <p>y</p> => <p>x</p><p>y[]</p><p>z</p> (no merging)\n * \t\t<p>x</p>[<img />]<p>z</p> + <p>y</p> => <p>x</p>^<p>z</p> + <p>y</p> => <p>x</p><p>y[]</p><p>z</p>\n *\n * If an instance of {@link module:engine/model/selection~Selection} is passed as `selectable` it will be modified\n * to the insertion selection (equal to a range to be selected after insertion).\n *\n * If `selectable` is not passed, the content will be inserted using the current selection of the model document.\n *\n * **Note:** Use {@link module:engine/model/model~Model#insertContent} instead of this function.\n * This function is only exposed to be reusable in algorithms which change the {@link module:engine/model/model~Model#insertContent}\n * method's behavior.\n *\n * @param {module:engine/model/model~Model} model The model in context of which the insertion\n * should be performed.\n * @param {module:engine/model/documentfragment~DocumentFragment|module:engine/model/item~Item} content The content to insert.\n * @param {module:engine/model/selection~Selectable} [selectable=model.document.selection]\n * Selection into which the content should be inserted.\n * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n * @returns {module:engine/model/range~Range} Range which contains all the performed changes. This is a range that, if removed,\n * would return the model to the state before the insertion. If no changes were preformed by `insertContent`, returns a range collapsed\n * at the insertion position.\n */\nexport default function insertContent( model, content, selectable, placeOrOffset ) {\n\treturn model.change( writer => {\n\t\tlet selection;\n\n\t\tif ( !selectable ) {\n\t\t\tselection = model.document.selection;\n\t\t} else if ( selectable instanceof Selection || selectable instanceof DocumentSelection ) {\n\t\t\tselection = selectable;\n\t\t} else {\n\t\t\tselection = writer.createSelection( selectable, placeOrOffset );\n\t\t}\n\n\t\tif ( !selection.isCollapsed ) {\n\t\t\tmodel.deleteContent( selection, { doNotAutoparagraph: true } );\n\t\t}\n\n\t\tconst insertion = new Insertion( model, writer, selection.anchor );\n\n\t\tlet nodesToInsert;\n\n\t\tif ( content.is( 'documentFragment' ) ) {\n\t\t\tnodesToInsert = content.getChildren();\n\t\t} else {\n\t\t\tnodesToInsert = [ content ];\n\t\t}\n\n\t\tinsertion.handleNodes( nodesToInsert );\n\n\t\tconst newRange = insertion.getSelectionRange();\n\n\t\t/* istanbul ignore else */\n\t\tif ( newRange ) {\n\t\t\tif ( selection instanceof DocumentSelection ) {\n\t\t\t\twriter.setSelection( newRange );\n\t\t\t} else {\n\t\t\t\tselection.setTo( newRange );\n\t\t\t}\n\t\t} else {\n\t\t\t// We are not testing else because it's a safe check for unpredictable edge cases:\n\t\t\t// an insertion without proper range to select.\n\t\t\t//\n\t\t\t// @if CK_DEBUG // console.warn( 'Cannot determine a proper selection range after insertion.' );\n\t\t}\n\n\t\tconst affectedRange = insertion.getAffectedRange() || model.createRange( selection.anchor );\n\n\t\tinsertion.destroy();\n\n\t\treturn affectedRange;\n\t} );\n}\n\n/**\n * Utility class for performing content insertion.\n *\n * @private\n */\nclass Insertion {\n\tconstructor( model, writer, position ) {\n\t\t/**\n\t\t * The model in context of which the insertion should be performed.\n\t\t *\n\t\t * @member {module:engine/model~Model} #model\n\t\t */\n\t\tthis.model = model;\n\n\t\t/**\n\t\t * Batch to which operations will be added.\n\t\t *\n\t\t * @member {module:engine/controller/writer~Batch} #writer\n\t\t */\n\t\tthis.writer = writer;\n\n\t\t/**\n\t\t * The position at which (or near which) the next node will be inserted.\n\t\t *\n\t\t * @member {module:engine/model/position~Position} #position\n\t\t */\n\t\tthis.position = position;\n\n\t\t/**\n\t\t * Elements with which the inserted elements can be merged.\n\t\t *\n\t\t *\t\t<p>x^</p><p>y</p> + <p>z</p> (can merge to <p>x</p>)\n\t\t *\t\t<p>x</p><p>^y</p> + <p>z</p> (can merge to <p>y</p>)\n\t\t *\t\t<p>x^y</p> + <p>z</p> (can merge to <p>xy</p> which will be split during the action,\n\t\t *\t\t\t\t\t\t\t\tso both its pieces will be added to this set)\n\t\t *\n\t\t *\n\t\t * @member {Set} #canMergeWith\n\t\t */\n\t\tthis.canMergeWith = new Set( [ this.position.parent ] );\n\n\t\t/**\n\t\t * Schema of the model.\n\t\t *\n\t\t * @member {module:engine/model/schema~Schema} #schema\n\t\t */\n\t\tthis.schema = model.schema;\n\n\t\t/**\n\t\t * The temporary DocumentFragment used for grouping multiple nodes for single insert operation.\n\t\t *\n\t\t * @private\n\t\t * @type {module:engine/model/documentfragment~DocumentFragment}\n\t\t */\n\t\tthis._documentFragment = writer.createDocumentFragment();\n\n\t\t/**\n\t\t * The current position in the temporary DocumentFragment.\n\t\t *\n\t\t * @private\n\t\t * @type {module:engine/model/position~Position}\n\t\t */\n\t\tthis._documentFragmentPosition = writer.createPositionAt( this._documentFragment, 0 );\n\n\t\t/**\n\t\t * The reference to the first inserted node.\n\t\t *\n\t\t * @private\n\t\t * @type {module:engine/model/node~Node}\n\t\t */\n\t\tthis._firstNode = null;\n\n\t\t/**\n\t\t * The reference to the last inserted node.\n\t\t *\n\t\t * @private\n\t\t * @type {module:engine/model/node~Node}\n\t\t */\n\t\tthis._lastNode = null;\n\n\t\t/**\n\t\t * The array of nodes that should be cleaned of not allowed attributes.\n\t\t *\n\t\t * @private\n\t\t * @type {Array.<module:engine/model/node~Node>}\n\t\t */\n\t\tthis._filterAttributesOf = [];\n\n\t\t/**\n\t\t * Beginning of the affected range. See {@link module:engine/model/utils/insertcontent~Insertion#getAffectedRange}.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/model/liveposition~LivePosition|null} #_affectedStart\n\t\t */\n\t\tthis._affectedStart = null;\n\n\t\t/**\n\t\t * End of the affected range. See {@link module:engine/model/utils/insertcontent~Insertion#getAffectedRange}.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/model/liveposition~LivePosition|null} #_affectedEnd\n\t\t */\n\t\tthis._affectedEnd = null;\n\t}\n\n\t/**\n\t * Handles insertion of a set of nodes.\n\t *\n\t * @param {Iterable.<module:engine/model/node~Node>} nodes Nodes to insert.\n\t */\n\thandleNodes( nodes ) {\n\t\tfor ( const node of Array.from( nodes ) ) {\n\t\t\tthis._handleNode( node );\n\t\t}\n\n\t\t// Insert nodes collected in temporary DocumentFragment.\n\t\tthis._insertPartialFragment();\n\n\t\t// After the content was inserted we may try to merge it with its next sibling if the selection was in it initially.\n\t\t// Merging with the previous sibling was performed just after inserting the first node to the document.\n\t\tthis._mergeOnRight();\n\n\t\t// TMP this will become a post-fixer.\n\t\tthis.schema.removeDisallowedAttributes( this._filterAttributesOf, this.writer );\n\t\tthis._filterAttributesOf = [];\n\t}\n\n\t/**\n\t * Returns range to be selected after insertion.\n\t * Returns `null` if there is no valid range to select after insertion.\n\t *\n\t * @returns {module:engine/model/range~Range|null}\n\t */\n\tgetSelectionRange() {\n\t\tif ( this.nodeToSelect ) {\n\t\t\treturn Range._createOn( this.nodeToSelect );\n\t\t}\n\n\t\treturn this.model.schema.getNearestSelectionRange( this.position );\n\t}\n\n\t/**\n\t * Returns a range which contains all the performed changes. This is a range that, if removed, would return the model to the state\n\t * before the insertion. Returns `null` if no changes were done.\n\t *\n\t * @returns {module:engine/model/range~Range|null}\n\t */\n\tgetAffectedRange() {\n\t\tif ( !this._affectedStart ) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn new Range( this._affectedStart, this._affectedEnd );\n\t}\n\n\t/**\n\t * Destroys `Insertion` instance.\n\t */\n\tdestroy() {\n\t\tif ( this._affectedStart ) {\n\t\t\tthis._affectedStart.detach();\n\t\t}\n\n\t\tif ( this._affectedEnd ) {\n\t\t\tthis._affectedEnd.detach();\n\t\t}\n\t}\n\n\t/**\n\t * Handles insertion of a single node.\n\t *\n\t * @private\n\t * @param {module:engine/model/node~Node} node\n\t */\n\t_handleNode( node ) {\n\t\t// Let's handle object in a special way.\n\t\t// * They should never be merged with other elements.\n\t\t// * If they are not allowed in any of the selection ancestors, they could be either autoparagraphed or totally removed.\n\t\tif ( this.schema.isObject( node ) ) {\n\t\t\tthis._handleObject( node );\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Try to find a place for the given node.\n\t\t// Split the position.parent's branch up to a point where the node can be inserted.\n\t\t// If it isn't allowed in the whole branch, then of course don't split anything.\n\t\tconst isAllowed = this._checkAndSplitToAllowedPosition( node );\n\n\t\tif ( !isAllowed ) {\n\t\t\tthis._handleDisallowedNode( node );\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Add node to the current temporary DocumentFragment.\n\t\tthis._appendToFragment( node );\n\n\t\t// Store the first and last nodes for easy access for merging with sibling nodes.\n\t\tif ( !this._firstNode ) {\n\t\t\tthis._firstNode = node;\n\t\t}\n\n\t\tthis._lastNode = node;\n\t}\n\n\t/**\n\t * Inserts the temporary DocumentFragment into the model.\n\t *\n\t * @private\n\t */\n\t_insertPartialFragment() {\n\t\tif ( this._documentFragment.isEmpty ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst livePosition = LivePosition.fromPosition( this.position, 'toNext' );\n\n\t\tthis._setAffectedBoundaries( this.position );\n\n\t\t// If the very first node of the whole insertion process is inserted, insert it separately for OT reasons (undo).\n\t\t// Note: there can be multiple calls to `_insertPartialFragment()` during one insertion process.\n\t\t// Note: only the very first node can be merged so we have to do separate operation only for it.\n\t\tif ( this._documentFragment.getChild( 0 ) == this._firstNode ) {\n\t\t\tthis.writer.insert( this._firstNode, this.position );\n\n\t\t\t// We must merge the first node just after inserting it to avoid problems with OT.\n\t\t\t// (See: https://github.com/ckeditor/ckeditor5/pull/8773#issuecomment-760945652).\n\t\t\tthis._mergeOnLeft();\n\n\t\t\tthis.position = livePosition.toPosition();\n\t\t}\n\n\t\t// Insert the remaining nodes from document fragment.\n\t\tif ( !this._documentFragment.isEmpty ) {\n\t\t\tthis.writer.insert( this._documentFragment, this.position );\n\t\t}\n\n\t\tthis._documentFragmentPosition = this.writer.createPositionAt( this._documentFragment, 0 );\n\n\t\tthis.position = livePosition.toPosition();\n\t\tlivePosition.detach();\n\t}\n\n\t/**\n\t * @private\n\t * @param {module:engine/model/element~Element} node The object element.\n\t */\n\t_handleObject( node ) {\n\t\t// Try finding it a place in the tree.\n\t\tif ( this._checkAndSplitToAllowedPosition( node ) ) {\n\t\t\tthis._appendToFragment( node );\n\t\t}\n\t\t// Try autoparagraphing.\n\t\telse {\n\t\t\tthis._tryAutoparagraphing( node );\n\t\t}\n\t}\n\n\t/**\n\t * @private\n\t * @param {module:engine/model/node~Node} node The disallowed node which needs to be handled.\n\t */\n\t_handleDisallowedNode( node ) {\n\t\t// If the node is an element, try inserting its children (strip the parent).\n\t\tif ( node.is( 'element' ) ) {\n\t\t\tthis.handleNodes( node.getChildren() );\n\t\t}\n\t\t// If text is not allowed, try autoparagraphing it.\n\t\telse {\n\t\t\tthis._tryAutoparagraphing( node );\n\t\t}\n\t}\n\n\t/**\n\t * Append a node to the temporary DocumentFragment.\n\t *\n\t * @private\n\t * @param {module:engine/model/node~Node} node The node to insert.\n\t */\n\t_appendToFragment( node ) {\n\t\t/* istanbul ignore if */\n\t\tif ( !this.schema.checkChild( this.position, node ) ) {\n\t\t\t// Algorithm's correctness check. We should never end up here but it's good to know that we did.\n\t\t\t// Note that it would often be a silent issue if we insert node in a place where it's not allowed.\n\n\t\t\t/**\n\t\t\t * Given node cannot be inserted on the given position.\n\t\t\t *\n\t\t\t * @error insertcontent-wrong-position\n\t\t\t * @param {module:engine/model/node~Node} node Node to insert.\n\t\t\t * @param {module:engine/model/position~Position} position Position to insert the node at.\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'insertcontent-wrong-position',\n\t\t\t\tthis,\n\t\t\t\t{ node, position: this.position }\n\t\t\t);\n\t\t}\n\n\t\tthis.writer.insert( node, this._documentFragmentPosition );\n\t\tthis._documentFragmentPosition = this._documentFragmentPosition.getShiftedBy( node.offsetSize );\n\n\t\t// The last inserted object should be selected because we can't put a collapsed selection after it.\n\t\tif ( this.schema.isObject( node ) && !this.schema.checkChild( this.position, '$text' ) ) {\n\t\t\tthis.nodeToSelect = node;\n\t\t} else {\n\t\t\tthis.nodeToSelect = null;\n\t\t}\n\n\t\tthis._filterAttributesOf.push( node );\n\t}\n\n\t/**\n\t * Sets `_affectedStart` and `_affectedEnd` to the given `position`. Should be used before a change is done during insertion process to\n\t * mark the affected range.\n\t *\n\t * This method is used before inserting a node or splitting a parent node. `_affectedStart` and `_affectedEnd` are also changed\n\t * during merging, but the logic there is more complicated so it is left out of this function.\n\t *\n\t * @private\n\t * @param {module:engine/model/position~Position} position\n\t */\n\t_setAffectedBoundaries( position ) {\n\t\t// Set affected boundaries stickiness so that those position will \"expand\" when something is inserted in between them:\n\t\t// <paragraph>Foo][bar</paragraph> -> <paragraph>Foo]xx[bar</paragraph>\n\t\t// This is why it cannot be a range but two separate positions.\n\t\tif ( !this._affectedStart ) {\n\t\t\tthis._affectedStart = LivePosition.fromPosition( position, 'toPrevious' );\n\t\t}\n\n\t\t// If `_affectedEnd` is before the new boundary position, expand `_affectedEnd`. This can happen if first inserted node was\n\t\t// inserted into the parent but the next node is moved-out of that parent:\n\t\t// (1) <paragraph>Foo][</paragraph> -> <paragraph>Foo]xx[</paragraph>\n\t\t// (2) <paragraph>Foo]xx[</paragraph> -> <paragraph>Foo]xx</paragraph><widget></widget>[\n\t\tif ( !this._affectedEnd || this._affectedEnd.isBefore( position ) ) {\n\t\t\tif ( this._affectedEnd ) {\n\t\t\t\tthis._affectedEnd.detach();\n\t\t\t}\n\n\t\t\tthis._affectedEnd = LivePosition.fromPosition( position, 'toNext' );\n\t\t}\n\t}\n\n\t/**\n\t * Merges the previous sibling of the first node if it should be merged.\n\t *\n\t * After the content was inserted we may try to merge it with its siblings.\n\t * This should happen only if the selection was in those elements initially.\n\t *\n\t * @private\n\t */\n\t_mergeOnLeft() {\n\t\tconst node = this._firstNode;\n\n\t\tif ( !( node instanceof Element ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !this._canMergeLeft( node ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst mergePosLeft = LivePosition._createBefore( node );\n\t\tmergePosLeft.stickiness = 'toNext';\n\n\t\tconst livePosition = LivePosition.fromPosition( this.position, 'toNext' );\n\n\t\t// If `_affectedStart` is sames as merge position, it means that the element \"marked\" by `_affectedStart` is going to be\n\t\t// removed and its contents will be moved. This won't transform `LivePosition` so `_affectedStart` needs to be moved\n\t\t// by hand to properly reflect affected range. (Due to `_affectedStart` and `_affectedEnd` stickiness, the \"range\" is\n\t\t// shown as `][`).\n\t\t//\n\t\t// Example - insert `<paragraph>Abc</paragraph><paragraph>Xyz</paragraph>` at the end of `<paragraph>Foo^</paragraph>`:\n\t\t//\n\t\t// <paragraph>Foo</paragraph><paragraph>Bar</paragraph>   -->\n\t\t// <paragraph>Foo</paragraph>]<paragraph>Abc</paragraph><paragraph>Xyz</paragraph>[<paragraph>Bar</paragraph>   -->\n\t\t// <paragraph>Foo]Abc</paragraph><paragraph>Xyz</paragraph>[<paragraph>Bar</paragraph>\n\t\t//\n\t\t// Note, that if we are here then something must have been inserted, so `_affectedStart` and `_affectedEnd` have to be set.\n\t\tif ( this._affectedStart.isEqual( mergePosLeft ) ) {\n\t\t\tthis._affectedStart.detach();\n\t\t\tthis._affectedStart = LivePosition._createAt( mergePosLeft.nodeBefore, 'end', 'toPrevious' );\n\t\t}\n\n\t\t// We need to update the references to the first and last nodes if they will be merged into the previous sibling node\n\t\t// because the reference would point to the removed node.\n\t\t//\n\t\t// <p>A^A</p> + <p>X</p>\n\t\t//\n\t\t// <p>A</p>^<p>A</p>\n\t\t// <p>A</p><p>X</p><p>A</p>\n\t\t// <p>AX</p><p>A</p>\n\t\t// <p>AXA</p>\n\t\tif ( this._firstNode === this._lastNode ) {\n\t\t\tthis._firstNode = mergePosLeft.nodeBefore;\n\t\t\tthis._lastNode = mergePosLeft.nodeBefore;\n\t\t}\n\n\t\tthis.writer.merge( mergePosLeft );\n\n\t\t// If only one element (the merged one) is in the \"affected range\", also move the affected range end appropriately.\n\t\t//\n\t\t// Example - insert `<paragraph>Abc</paragraph>` at the of `<paragraph>Foo^</paragraph>`:\n\t\t//\n\t\t// <paragraph>Foo</paragraph><paragraph>Bar</paragraph>   -->\n\t\t// <paragraph>Foo</paragraph>]<paragraph>Abc</paragraph>[<paragraph>Bar</paragraph>   -->\n\t\t// <paragraph>Foo]Abc</paragraph>[<paragraph>Bar</paragraph>   -->\n\t\t// <paragraph>Foo]Abc[</paragraph><paragraph>Bar</paragraph>\n\t\tif ( mergePosLeft.isEqual( this._affectedEnd ) && this._firstNode === this._lastNode ) {\n\t\t\tthis._affectedEnd.detach();\n\t\t\tthis._affectedEnd = LivePosition._createAt( mergePosLeft.nodeBefore, 'end', 'toNext' );\n\t\t}\n\n\t\tthis.position = livePosition.toPosition();\n\t\tlivePosition.detach();\n\n\t\t// After merge elements that were marked by _insert() to be filtered might be gone so\n\t\t// we need to mark the new container.\n\t\tthis._filterAttributesOf.push( this.position.parent );\n\n\t\tmergePosLeft.detach();\n\t}\n\n\t/**\n\t * Merges the next sibling of the last node if it should be merged.\n\t *\n\t * After the content was inserted we may try to merge it with its siblings.\n\t * This should happen only if the selection was in those elements initially.\n\t *\n\t * @private\n\t */\n\t_mergeOnRight() {\n\t\tconst node = this._lastNode;\n\n\t\tif ( !( node instanceof Element ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !this._canMergeRight( node ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst mergePosRight = LivePosition._createAfter( node );\n\t\tmergePosRight.stickiness = 'toNext';\n\n\t\t/* istanbul ignore if */\n\t\tif ( !this.position.isEqual( mergePosRight ) ) {\n\t\t\t// Algorithm's correctness check. We should never end up here but it's good to know that we did.\n\t\t\t// At this point the insertion position should be after the node we'll merge. If it isn't,\n\t\t\t// it should need to be secured as in the left merge case.\n\t\t\t/**\n\t\t\t * An internal error occurred when merging inserted content with its siblings.\n\t\t\t * The insertion position should equal the merge position.\n\t\t\t *\n\t\t\t * If you encountered this error, report it back to the CKEditor 5 team\n\t\t\t * with as many details as possible regarding the content being inserted and the insertion position.\n\t\t\t *\n\t\t\t * @error insertcontent-invalid-insertion-position\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'insertcontent-invalid-insertion-position', this );\n\t\t}\n\n\t\t// Move the position to the previous node, so it isn't moved to the graveyard on merge.\n\t\t// <p>x</p>[]<p>y</p> => <p>x[]</p><p>y</p>\n\t\tthis.position = Position._createAt( mergePosRight.nodeBefore, 'end' );\n\n\t\t// Explanation of setting position stickiness to `'toPrevious'`:\n\t\t// OK:  <p>xx[]</p> + <p>yy</p> => <p>xx[]yy</p> (when sticks to previous)\n\t\t// NOK: <p>xx[]</p> + <p>yy</p> => <p>xxyy[]</p> (when sticks to next)\n\t\tconst livePosition = LivePosition.fromPosition( this.position, 'toPrevious' );\n\n\t\t// See comment in `_mergeOnLeft()` on moving `_affectedStart`.\n\t\tif ( this._affectedEnd.isEqual( mergePosRight ) ) {\n\t\t\tthis._affectedEnd.detach();\n\t\t\tthis._affectedEnd = LivePosition._createAt( mergePosRight.nodeBefore, 'end', 'toNext' );\n\t\t}\n\n\t\t// We need to update the references to the first and last nodes if they will be merged into the previous sibling node\n\t\t// because the reference would point to the removed node.\n\t\t//\n\t\t// <p>A^A</p> + <p>X</p>\n\t\t//\n\t\t// <p>A</p>^<p>A</p>\n\t\t// <p>A</p><p>X</p><p>A</p>\n\t\t// <p>AX</p><p>A</p>\n\t\t// <p>AXA</p>\n\t\tif ( this._firstNode === this._lastNode ) {\n\t\t\tthis._firstNode = mergePosRight.nodeBefore;\n\t\t\tthis._lastNode = mergePosRight.nodeBefore;\n\t\t}\n\n\t\tthis.writer.merge( mergePosRight );\n\n\t\t// See comment in `_mergeOnLeft()` on moving `_affectedStart`.\n\t\tif ( mergePosRight.getShiftedBy( -1 ).isEqual( this._affectedStart ) && this._firstNode === this._lastNode ) {\n\t\t\tthis._affectedStart.detach();\n\t\t\tthis._affectedStart = LivePosition._createAt( mergePosRight.nodeBefore, 0, 'toPrevious' );\n\t\t}\n\n\t\tthis.position = livePosition.toPosition();\n\t\tlivePosition.detach();\n\n\t\t// After merge elements that were marked by _insert() to be filtered might be gone so\n\t\t// we need to mark the new container.\n\t\tthis._filterAttributesOf.push( this.position.parent );\n\n\t\tmergePosRight.detach();\n\t}\n\n\t/**\n\t * Checks whether specified node can be merged with previous sibling element.\n\t *\n\t * @private\n\t * @param {module:engine/model/node~Node} node The node which could potentially be merged.\n\t * @returns {Boolean}\n\t */\n\t_canMergeLeft( node ) {\n\t\tconst previousSibling = node.previousSibling;\n\n\t\treturn ( previousSibling instanceof Element ) &&\n\t\t\tthis.canMergeWith.has( previousSibling ) &&\n\t\t\tthis.model.schema.checkMerge( previousSibling, node );\n\t}\n\n\t/**\n\t * Checks whether specified node can be merged with next sibling element.\n\t *\n\t * @private\n\t * @param {module:engine/model/node~Node} node The node which could potentially be merged.\n\t * @returns {Boolean}\n\t */\n\t_canMergeRight( node ) {\n\t\tconst nextSibling = node.nextSibling;\n\n\t\treturn ( nextSibling instanceof Element ) &&\n\t\t\tthis.canMergeWith.has( nextSibling ) &&\n\t\t\tthis.model.schema.checkMerge( node, nextSibling );\n\t}\n\n\t/**\n\t * Tries wrapping the node in a new paragraph and inserting it this way.\n\t *\n\t * @private\n\t * @param {module:engine/model/node~Node} node The node which needs to be autoparagraphed.\n\t */\n\t_tryAutoparagraphing( node ) {\n\t\tconst paragraph = this.writer.createElement( 'paragraph' );\n\n\t\t// Do not autoparagraph if the paragraph won't be allowed there,\n\t\t// cause that would lead to an infinite loop. The paragraph would be rejected in\n\t\t// the next _handleNode() call and we'd be here again.\n\t\tif ( this._getAllowedIn( paragraph, this.position.parent ) && this.schema.checkChild( paragraph, node ) ) {\n\t\t\tparagraph._appendChild( node );\n\t\t\tthis._handleNode( paragraph );\n\t\t}\n\t}\n\n\t/**\n\t * @private\n\t * @param {module:engine/model/node~Node} node\n\t * @returns {Boolean} Whether an allowed position was found.\n\t * `false` is returned if the node isn't allowed at any position up in the tree, `true` if was.\n\t */\n\t_checkAndSplitToAllowedPosition( node ) {\n\t\tconst allowedIn = this._getAllowedIn( node, this.position.parent );\n\n\t\tif ( !allowedIn ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Insert nodes collected in temporary DocumentFragment if the position parent needs change to process further nodes.\n\t\tif ( allowedIn != this.position.parent ) {\n\t\t\tthis._insertPartialFragment();\n\t\t}\n\n\t\twhile ( allowedIn != this.position.parent ) {\n\t\t\t// If a parent which we'd need to leave is a limit element, break.\n\t\t\tif ( this.schema.isLimit( this.position.parent ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif ( this.position.isAtStart ) {\n\t\t\t\t// If insertion position is at the beginning of the parent, move it out instead of splitting.\n\t\t\t\t// <p>^Foo</p> -> ^<p>Foo</p>\n\t\t\t\tconst parent = this.position.parent;\n\n\t\t\t\tthis.position = this.writer.createPositionBefore( parent );\n\n\t\t\t\t// Special case – parent is empty (<p>^</p>).\n\t\t\t\t//\n\t\t\t\t// 1. parent.isEmpty\n\t\t\t\t// We can remove the element after moving insertion position out of it.\n\t\t\t\t//\n\t\t\t\t// 2. parent.parent === allowedIn\n\t\t\t\t// However parent should remain in place when allowed element is above limit element in document tree.\n\t\t\t\t// For example there shouldn't be allowed to remove empty paragraph from tableCell, when is pasted\n\t\t\t\t// content allowed in $root.\n\t\t\t\tif ( parent.isEmpty && parent.parent === allowedIn ) {\n\t\t\t\t\tthis.writer.remove( parent );\n\t\t\t\t}\n\t\t\t} else if ( this.position.isAtEnd ) {\n\t\t\t\t// If insertion position is at the end of the parent, move it out instead of splitting.\n\t\t\t\t// <p>Foo^</p> -> <p>Foo</p>^\n\t\t\t\tthis.position = this.writer.createPositionAfter( this.position.parent );\n\t\t\t} else {\n\t\t\t\tconst tempPos = this.writer.createPositionAfter( this.position.parent );\n\n\t\t\t\tthis._setAffectedBoundaries( this.position );\n\t\t\t\tthis.writer.split( this.position );\n\n\t\t\t\tthis.position = tempPos;\n\n\t\t\t\tthis.canMergeWith.add( this.position.nodeAfter );\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Gets the element in which the given node is allowed. It checks the passed element and all its ancestors.\n\t *\n\t * @private\n\t * @param {module:engine/model/node~Node} node The node to check.\n\t * @param {module:engine/model/element~Element} element The element in which the node's correctness should be checked.\n\t * @returns {module:engine/model/element~Element|null}\n\t */\n\t_getAllowedIn( node, element ) {\n\t\tif ( this.schema.checkChild( element, node ) ) {\n\t\t\treturn element;\n\t\t}\n\n\t\tif ( element.parent ) {\n\t\t\treturn this._getAllowedIn( node, element.parent );\n\t\t}\n\n\t\treturn null;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}